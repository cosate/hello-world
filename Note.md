# C++笔记
---

1. C++对象模型  
C++类成员分为static和nonstatic成员变量，static、nonstatic和virtual函数。在内存中：  

 * 类的非静态成员变量（和虚函数表指针以及内存对齐支出）构成了每个类实例的内存空间，根据对象的建立方式，可存放在堆和栈上。这点与struct类似；
 * 类的静态成员变量存储在内存全局/静态变量区，为该类所有对象共有；
 * 类的成员函数，无论静态还是非静态，都存储在代码区，为所有对象共有，不是为每个对象创建副本；
 * 类的静态成员函数和非静态成员函数的区别仅在于包不包含this指针参数，由此导致静态成员函数无法访问非静态成员变量。
 * 虚函数的内存模型详见下节。

2. C++虚函数内存模型  
 这篇文章[C++虚函数内存模型](http://www.cnblogs.com/QG-whz/p/4909359.html)写得很好，文中有些小笔误（或者配图错误），注意别被误导就行了。

3. C++11 C++14 C++17新特性  

4. 不能被复制的类  
核心思想是把拷贝构造函数私有，在C++11中有新的关键字实现。

5. 不能被继承的类  
分三种种思路：
 * 构造函数私有，同时使用公有static函数来构造对象,其实就是单例模式；
 * 一个构造函数私有的类，一个子类虚继承自该类，同时父类使子类为自己的友元类，则子类能构造父类，但不能被继承。  
 * C++11 final关键字。
6. 模板  
7. 智能指针 shared_ptr实现 bind实现
8. STL rotate map的key vector扩容策略
9. 序列化
10. 反射 闭包 继承类型
11. dynamic_cast static_cast
12. std::function
13. 实现向量的延迟计算 表达式模板
14. 判断是C编译器还是C++编译器
15. explicit
16. C++单元测试
17. malloc/free new/delete malloc实现
18. DNS服务器
19. 连续分配的int在栈上地址相差12字节，是因为debug模式下前后各有4字节的调试信息，改为release模式后相差就是4字节。
20. 不考虑各种编译器的优化，函数在返回值前先调用复制构造函数构造临时对象。
21. 考虑优化的情况下，不同编译器会减少复制构造的次数。在C++11标准中，move语义即是为了解决该项性能问题而提出的：move把左值转为右值，在自定义类型中重载实现右值引用的构造函数，可以减少在相应位置处的构造操作。其核心还是右值引用的构造函数的重载，比如含指针成员的类，可以避免深拷贝的开销，把原对象指针赋为NULL就行了；move只是强转类型。
 
# Python笔记
---


# 算法笔记
---
1. 遍历一遍ip字符串判断格式是否正确
2. 
